type: "MARKDOWN_NOTE"
folder: "8d19d56ee029f3fa592b"
title: "Number of Island II"
content: '''
  # Number of Island II
  对于一个静态的地图，统计岛屿个数可以使用dfs（类似于寻找一个图中的连通块个数），算法复杂度是`O(mn)`。但是对于一个不断更新的地图，如果我们每次重新统计连通块个数，复杂度为`O(mnk)`，其中k为总操作个数。考虑到每次只有一个位置发生变化（从0变为1），完全不必重新统一，该陆地的产生职能影响周围四个位置。假设该陆地周围有t（p至多为4）个不连通的岛屿，那么该陆地为把这四个不同点岛屿合并为一个岛屿，使得总岛屿数下降t-1个。因此我们需要维护岛屿之间的连通性，自然的我们想到了并查集。并查集是一种解决此类问题的强力数据结构，以此题为例，初始时每个位置都是独立的、互不连通的，每个位置都有一个标签来identify自己，记录在fa数组中，fa[i]为i。当两个位置p、q相邻且都为1时，这两个位置需要统一它们的标签（表示这两个岛屿合并），即fa[p] = q。但是p、q的标签可能已经被修改，因此我们需要通过getfather函数递归找到它们的真实标签（getfather(i)的返回值也称为i的祖先），合并操作变为`fa[getfather(p)] = getfather(q)`。为了防止最坏情况下每次调用getfather函数都要经过mn次递归，我们可以采用路径压缩的方法（详见代码中getfather函数），使得每个位置到其祖先的距离始终为一个很小的常数（与m、n无关）。本题中总体时间复杂度为`O(mn+k)`，其中每次并查集的查询复杂度为一个常数（不超过4）。
'''
tags: []
isStarred: false
isTrashed: false
createdAt: "2017-09-14T18:07:38.873Z"
updatedAt: "2017-09-14T18:11:06.420Z"
