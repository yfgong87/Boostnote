type: "MARKDOWN_NOTE"
folder: "8d19d56ee029f3fa592b"
title: "Longest Substring without repeating character"
content: '''
  # Longest Substring without repeating character
  - 暴力枚举`O(n^3)`
  ### 模板
  ```java
  public class Solution {
      /*
       * @param s: a string
       * @return: an integer
       */
      public int lengthOfLongestSubstring(String s) {
          int[] map = new int[256];
          int start = 0;
          int end = 0;
  		//count 代表遇到 Repeating Character 的个数
          int count = 0;
          int max = 0;
          while(end < s.length()){
  			//遇到了一个 Repeating Character
  			// map[s.charAt(end)] > 0
              if(map[s.charAt(end)] == 1){
                  count++;
              }
  			map[s.charAt(end)]++;
  			end++;			
  			//SubString 中一旦有 Repeating Char
  			//向右移动 start 直到这个 Char 被移出 SubString
              while(count > 0){
  				// map[s.charAt(start)] > 1
                  if(map[s.charAt(start)] == 2){
                      count--;
                  }
                  map[s.charAt(start)]--;
                  start++; 
              }
  			// end - start 是因为 end 在上面 ++ 了，要退回一格
              max = Math.max(max, end - start);
          }
          return max;
      }
  }
  ```
  ### Sliding window 解法。
  `i` 和 `j` 两个指针从左向右，`j` 不断向右，记录最大的`subString`长度，直到遇到重复 `char`，每当 `j` 遇到重复 `char`，`i` 向右一格，并且 `i` 所在的元素从重复 `char` 中清除，一直循环到重复的`char`被从`subString`中拿掉。这样最坏的情况(“aaaa”)下每个指针都走了 `n` 次，`O(2n)` -> `O(n)`
  ```java
  class Solution {
      public int lengthOfLongestSubstring(String s) {
          int[] map = new int[256];
          int i = 0;
          int j = 0;
          int max = 0;
          while(i < s.length() && j < s.length()){
              if(map[s.charAt(j)] == 0){
                  map[s.charAt(j)] = 1;
                  max = Math.max(max, j - i + 1);
                  j++;
              } else {
                  map[s.charAt(i)] = 0;
                  i++; //以 i 开头的最长 substring
              }
          }
          return max;
      }
  }
  ```
  ### Longest Substring with At Most Two Distinct Characters
  Given a string, find the length of the longest substring T that contains at most 2 distinct characters.
  For example, Given s = `“eceba”`, T is `"ece"` which its length is `3`.
  ```java
  class Solution {
      public int lengthOfLongestSubstringTwoDistinct(String s) {
          int[] map = new int[256];
          int start = 0;
          int end = 0;
  		//count 代表遇到 Distinct Character 的个数
          int count = 0;
          int max = 0;
          while(end < s.length()){
  			//遇到了一个 Distinct Character
              if(map[s.charAt(end)] == 0){
                  count++;
              }
  			map[s.charAt(end)]++;
  			end++;			
  			//SubString 中一旦超过两个 Distinct Char
  			//向右移动 start 直到某个 Distinct Char 被移出 SubString
              while(count > 2){
                  if(map[s.charAt(start)] == 1){
                      count--;
                  }
                  map[s.charAt(start)]--;
                  start++; 
              }
              max = Math.max(max, end - start);
          }
          return max;
      }
  }
  ```
  
  ### Longest Substring with At Most K Distinct Characters
  ```java
  class Solution {
      public int lengthOfLongestSubstringKDistinct(String s, int k) {
          int[] map = new int[256];
          int start = 0;
          int end = 0;
  		//count 代表遇到 Distinct Character 的个数
          int count = 0;
          int max = 0;
          while(end < s.length()){
  			//遇到了一个 Distinct Character
              if(map[s.charAt(end)] == 0){
                  count++;
              }
  			map[s.charAt(end)]++;
  			end++;			
  			//SubString 中一旦超过k个 Distinct Char
  			//向右移动 start 直到某个 Distinct Char 被移出 SubString
              while(count > k){
                  if(map[s.charAt(start)] == 1){
                      count--;
                  }
                  map[s.charAt(start)]--;
                  start++; 
              }
              max = Math.max(max, end - start);
          }
          return max;
      }
  }
  ```
  ### Minimum Window Substring
  Given a string source and a string target, find the minimum window in source which will contain all the characters in target.
  Should the characters in minimum window has the same order in target? `NO`
  For source = `"CDBAC"`, target = `"ABC"`, the minimum window is `"BAC"`
  ```java
  public class Solution {
      /*
       * @param source : A string
       * @param target: A string
       * @return: A string denote the minimum window, return "" if there is no such a string
       */
      public String minWindow(String source , String target) {
          // write your code here
          int[] map = new int[256];
          for(int i = 0; i < target.length(); i++){
              map[target.charAt(i)]++;
          }
          int start = 0;
          int end = 0;
  		//count 代表 target 中已经被放进 Substring 的 char 的数目
          int count = 0; 
          int min = Integer.MAX_VALUE;
          int minStart = start;
          int minEnd = end;
          while(end < source.length()){
              if(map[source.charAt(end)] > 0){
                  count++;
              }
              map[source.charAt(end)]--;
              end++;
  			//当 Substring 中已经包含了 target 中所有的 Char
  			//向右移动 start 寻找最小 Substring，直到某个 Char 被移出 Substring
              while(count == target.length()){
                  if(end - start < min){
                      minStart = start;
                      minEnd = end;
                      min = end - start;
                  }
                  map[source.charAt(start)]++;
                  if(map[source.charAt(start)] > 0){
                      count--;
                  }
                  start++;
              }
          }
          return source.substring(minStart, minEnd);
      }
  }
  ```
'''
tags: [
  "Sliding_Window"
  "Two_Pointer"
]
isStarred: false
isTrashed: false
createdAt: "2017-11-03T23:38:44.423Z"
updatedAt: "2018-01-03T15:05:55.779Z"
