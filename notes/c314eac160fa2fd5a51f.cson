createdAt: "2018-01-21T02:37:21.924Z"
updatedAt: "2018-01-21T02:39:28.571Z"
type: "MARKDOWN_NOTE"
folder: "df7fbd4f413bd7e56cde"
title: "Search for a Range"
content: '''
  # Search for a Range
  
  Solution: 
  
  Use Binary search to find a target, then use two pointers, starting from the target index, one moving towards left, another towards right, until the number they are pointing to are not target any more, then return the position of the two pointers.
  
  Time complexity: `O(logn) + O(k)` where `k` is the number of occurrence of the target
  ```java
  public class Solution {
      /*
       * @param A: an integer sorted array
       * @param target: an integer to be inserted
       * @return: a list of length 2, [index1, index2]
       */
      public int[] searchRange(int[] A, int target) {
          // write your code here
          if(A == null || A.length == 0){
              return new int[]{-1, -1};
          }
          int start = 0;
          int end = A.length - 1;
          int mid = 0;
          while (start + 1 < end){
              mid = start + (end - start) / 2;
              if(A[mid] < target){
                  start = mid;
              } else {
                  end = mid;
              }
          }
          int index = 0;
          if(A[start] == target){
              index = start;
          } else if(A[end] == target){
              index = end;
          } else {
              return new int[]{-1, -1};
          }
          int startIndex = index;
          int endIndex = index;
          while(startIndex >= 0 && A[startIndex] == target){
              startIndex--;
          }
          while(endIndex < A.length && A[endIndex] == target){
              endIndex++;
          }
  		// startIndex 和 endIndex 各退回一格
          return new int[]{startIndex + 1, endIndex - 1};
      }
  }
  ```
'''
tags: [
  "Binary_Search"
  "Linkedin"
]
isStarred: false
isTrashed: false
