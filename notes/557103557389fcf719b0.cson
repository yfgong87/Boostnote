createdAt: "2018-01-02T01:26:07.098Z"
updatedAt: "2018-01-02T02:58:15.454Z"
type: "MARKDOWN_NOTE"
folder: "8d19d56ee029f3fa592b"
title: "Binary Search 难题汇总"
content: '''
  # Binary Search 难题汇总
  ### Total Occurrence of Target
  ```java
  public class Solution {
      /**
       * @param A an integer array sorted in ascending order
       * @param target an integer
       * @return an integer
       */
      public int totalOccurrence(int[] A, int target) {
          // Write your code here
          //ooooooTTTTxxxxxx
          //exception handling
          if (A.length == 0 || A == null){
              return 0;
          }
          int start = 0;
          int end = A.length - 1;
          int mid = 0;
          while(start + 1 < end){
              mid = start + (end - start) / 2;
              if(A[mid] == target){
                  end = mid;
              } else if(A[mid] < target){
                  start = mid;
              } else {
                  end = mid; // 保证不漏掉第一个出现的 target
              }
          }
          int index = 0;
          int count = 0;
          if(A[start] == target){
              index = start + 1;
              count++;
          } else if(A[end] == target){
              index = end + 1;
              count++;
          } else {
              return count;
          }
          while(index < A.length && A[index] == target){
              count++;
              index++;
          }
          return count;
      }
  }
  ```
  ### Search for a Range
  ```java
  public class Solution {
      /*
       * @param A: an integer sorted array
       * @param target: an integer to be inserted
       * @return: a list of length 2, [index1, index2]
       */
      public int[] searchRange(int[] A, int target) {
          // write your code here
          if(A == null || A.length == 0){
              return new int[]{-1, -1};
          }
          int start = 0;
          int end = A.length - 1;
          int mid = 0;
          while (start + 1 < end){
              mid = start + (end - start) / 2;
              if(A[mid] < target){
                  start = mid;
              } else {
                  end = mid;
              }
          }
          int index = 0;
          if(A[start] == target){
              index = start;
          } else if(A[end] == target){
              index = end;
          } else {
              return new int[]{-1, -1};
          }
          int startIndex = index;
          int endIndex = index;
          while(startIndex >= 0 && A[startIndex] == target){
              startIndex--;
          }
          while(endIndex < A.length && A[endIndex] == target){
              endIndex++;
          }
  		// startIndex 和 endIndex 各退回一格
          return new int[]{startIndex + 1, endIndex - 1};
      }
  }
  ```
'''
tags: [
  "Binary_Search"
]
isStarred: false
isTrashed: false
