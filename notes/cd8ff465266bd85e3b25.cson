createdAt: "2018-01-11T21:06:08.575Z"
updatedAt: "2018-01-11T21:15:59.522Z"
type: "MARKDOWN_NOTE"
folder: "c7615b6dcc7b2832aa16"
title: "Sort Color I - Partition into three parts"
content: '''
  ### Sort Color I - Partition into `three` parts
  `O(n)`æ—¶é—´å¤æ‚åº¦ï¼Œ`O(1)`ç©ºé—´å¤æ‚åº¦
  ```java
  class Solution {
      /**
       * @param nums: A list of integer which is 0, 1 or 2 
       * @return: nothing
       */
      public void sortColors(int[] nums) {
          // write your code here
          if(nums == null || nums.length == 0){
              return;
          }
          int left = 0;
          int right = nums.length - 1;
          int index = 0;
          while(index <= right){
              if(nums[index] == 0){
                  swap(nums, left, index);
                  left++;
                  index++; //è·Ÿå·¦è¾¹æ¢å®Œä¹‹å index å¯ä»¥èµ°ï¼Œå› ä¸ºæ¢å›æ¥çš„æ•°ä¸€å®šæ˜¯ 1
              } else if (nums[index] == 1){
                  index++;
              } else {
  				//æ³¨æ„è·Ÿå³è¾¹æ¢å®Œä¹‹å index ä¸èƒ½èµ°ï¼Œå› ä¸ºæ¢å›æ¥çš„æ•°å¹¶æ²¡æœ‰æ£€éªŒè¿‡
                  swap(nums, index, right);
                  right--;
              }
          }
      }
      
      public void swap(int[] nums, int i, int j){
          int temp = nums[i];
          nums[i] = nums[j];
          nums[j] = temp;
      }
  }
  ```
  ### Sort Colors II (Rainbow Sort / å½©è™¹æ’åºğŸŒˆ)
  å¾…ç¡®è®¤ï¼šæ—¶é—´å¤æ‚åº¦ä¸º `O(nlogk)`, `k`ä¸º `color`çš„æ•°ç›®
  
  Non-randomly Picking the `Pivot`
  è¿™é‡Œ `while (l <= r && colors[l] <= colorMid)`
  å¯¹äºè¿™ä¸ªwhileå¾ªç¯ä¸ºä»€ä¹ˆæ˜¯<= ä¸æ˜¯ < , å®ƒä¸ºä»€ä¹ˆå’Œå¿«æ’ä¸ä¸€æ ·å‘¢ ï¼Ÿ
  é¦–å…ˆç”±å¦‚ä¸‹å‡ ä¸ªåœ°æ–¹å¤§å®¶éœ€è¦æ³¨æ„ï¼š
  å› ä¸ºrainbowSortçš„é€’å½’é‡Œ (..., colorMid + 1, colorTo)ï¼Œæ‰€ä»¥colorMidçš„å€¼ä¸èƒ½æ··åˆ°å³è¾¹å»ï¼Œå› ä¸ºå³è¾¹å€¼çš„åŒºé—´æ˜¯`[colorMid + 1, colorTo]`, å·¦è¾¹çš„å€¼æ˜¯`[colorFrom, colorMid]`ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠç­‰äºcolorMidçš„å€¼æ”¾åœ¨partitionçš„å·¦ä¾§ã€‚è€Œä¸æ˜¯åƒå¿«æ’ä¸€æ ·ï¼Œç­‰äºpivotçš„å€¼çš„å…ƒç´ æ”¾åœ¨å·¦ä¾§æˆ–è€…å³ä¾§æ˜¯æ— æ‰€è°“çš„ã€‚æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬åº”è¯¥åˆ†åˆ«ä½¿ç”¨`colors[l] <= colorMid` å’Œ `color[r] > colorMid`
  å› ä¸º`colorFrom >= colorTo`çš„æ—¶å€™æˆ‘ä»¬å·²ç»returnäº†ï¼Œæ‰€ä»¥æ±‚colorMidçš„æ—¶å€™ï¼ŒcolorFromä¸€å®šä¸ç­‰äºcolorToã€‚åˆå› ä¸º`colorMid = ï¼ˆcolorFrom + colorToï¼‰ / 2`, æ‰€ä»¥colorMidä¸€å®šä¸ä¼šç­‰äºæœ€å¤§å€¼colorToï¼Œä¹Ÿå°±é¿å…äº†æˆ‘ä»¬æ‰€è¯´çš„å› ä¸ºpivotæ˜¯æœ€å¤§å€¼è€Œå¯¼è‡´æ— é™é€’å½’çš„é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ”¾å¿ƒçš„ä½¿ç”¨<=ã€‚
  ```java
  private void rainbowSort(int[] colors,
                        int start,
                        int end,
                        int colorFrom, 
                        int colorTo){
          if(start >= end){
              return;
          }           
          if(colorFrom >= colorTo){
              return;
          }
          int left = start;
          int right = end;
          int colorMid = (colorFrom + colorTo) / 2;
          while(left <= right){
              //æ³¨æ„è¿™é‡Œæ˜¯colors[left] <= colorMid,å› ä¸ºåœ¨é€’å½’æ—¶colorMidåªèƒ½å»å·¦è¾¹
              while(left <= right && colors[left] <= colorMid){
                  left++;
              }
              while(left <= right && colors[right] > colorMid){
                  right--;
              }
              if(left <= right){
                  int temp = colors[left];
                  colors[left] = colors[right];
                  colors[right] = temp;
                  left++;
                  right--;
              }
          }
          rainbowSort(colors, start, right, colorFrom, colorMid);
          rainbowSort(colors, left, end, colorMid + 1, colorTo);
      }
  ```
  ### Counting Sort
  ğŸŒˆå½©è™¹æ’åºçš„`HashMap`åšæ³•
  `2 * O(n)` æ—¶é—´å¤æ‚åº¦, `O(k)` extra memory 
  ```java
  class Solution {
      /**
       * @param colors: A list of integer
       * @param k: An integer
       * @return: nothing
       */
      public void sortColors2(int[] colors, int k) {
          // write your code here
          if(colors == null || colors.length == 0){
              return;
          }
          Map<Integer, Integer> map = new HashMap<Integer, Integer>();
          for(int color : colors){
              if(!map.containsKey(color)){
                  map.put(color, 1);
              } else {
                  map.put(color, map.get(color) + 1);
              }
          }
          int index = 0;
          for(int color = 1; color <= k; color++){
              if(!map.containsKey(color)){
                  continue;
              }
              for(int i = 0; i < map.get(color); i++){
                  colors[index] = color;
                  index++;
              }
          }
      }
  
  }
  ```
'''
tags: [
  "Sorting"
  "HashMap"
]
isStarred: false
isTrashed: false
