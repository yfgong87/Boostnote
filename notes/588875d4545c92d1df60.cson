type: "MARKDOWN_NOTE"
folder: "0ef4dc321cdc22cb8b00"
title: "Quick Sort, Heap Sort"
content: '''
  # Quick Sort, Heap Sort
  ### Quick Sort
  | Best TC | Average TC | Worst TC | Space C |
  | ------- | ---------  | -------- | ------- |
  | `O(nlogn)`	| `O(nlogn)` | 	`O(n^2)` | `O(logn)` |
  - `logn` space complexity because of stack use in recursion
  ![](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)
  ```java
  public class Solution {
      public void sortIntegers(int[] A) {
          // write your code here
          quickSort(A, 0, A.length - 1);
      }
      
      private void quickSort(int[] A, int left, int right){
          if(left >= right){
              return;
          }
          // key point: pivot is the value, not the index
          int pivot = A[(left + right) / 2];
          //get new pivot after partition
          int index = partition(A, pivot, left, right);
          quickSort(A, left, index - 1);
          quickSort(A, index, right);
      }
      
      //return new pivot
      private int partition(int[] A, int pivot, int left, int right){
          int temp = 0;
          //while left pointer has not met right pointer
          while(left <= right){
              //while left is smaller than pivot, 
              //keep moving left pointer to right
              while(A[left] < pivot){
                  left++;
              }
              //while right is bigger than pivot, 
              //keep moving right pointer to left
              while(A[right] > pivot){
                  right--;
              }
              //if left pointer has not met right pointer
              if(left <= right){
                  //swap
                  temp = A[left];
                  A[left] = A[right];
                  A[right] = temp;
                  left++;
                  right--;
              }
          }
          return left;
      }
      
  };
  ```
  å¿«æ’ä¹ç« æ¨¡æ¿
  - ä¸ºä»€ä¹ˆè¦ç”¨`left<=right`?
  å› ä¸ºæˆ‘ä»¬ä¸å¸Œæœ›ç­‰äºçš„æ—¶å€™åœä¸‹æ¥ï¼Œè€Œæ˜¯partitionæˆä¸¤ä»½ï¼Œæ­£åœ¨æ„ä¹‰ä¸Šåˆ†å¼€ï¼Œæ‰€ä»¥ç”¨äº†`left <= right` ä½¿å¾—ç»“æŸçš„æ—¶å€™`right`ä¸€å®šå°äº`left`
  - ä¸ºä»€ä¹ˆè¿™é‡Œæ˜¯`A[left] < pivot` è€Œä¸æ˜¯ `A[left] <= pivot` ?
  å› ä¸ºå¦‚æœpivotåˆšå¥½æ˜¯æœ€å¤§å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯¹nä¸ªå…ƒç´ è¿›è¡Œpartitionå°±ä¼šå‡ºç°å·¦è¾¹å¾—åˆ°nä¸ªï¼Œå³è¾¹å¾—åˆ°0ä¸ªå…ƒç´ çš„æƒ…å†µï¼Œè¿™æ ·å·¦è¾¹ç»§ç»­é€’å½’ä¸‹å»æœ‰å¯èƒ½å§‹ç»ˆéƒ½æ˜¯nï¼ˆæ¯æ¬¡å–å‡ºpivotéƒ½æ˜¯æœ€å¤§å€¼ï¼‰ï¼Œé‚£ä¹ˆä¼šå‡ºç°æ— é™é€’å½’ã€‚
  - ä¸ºä»€ä¹ˆè¿™é‡Œæ˜¯`A[right] > pivot` è€Œä¸æ˜¯ `A[right] >= pivot` ?
  åŒç†ï¼Œå› ä¸ºå¦‚æœpivotåˆšå¥½æ˜¯æœ€å°å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯¹nä¸ªå…ƒç´ è¿›è¡Œpartitionå°±ä¼šå‡ºç°å·¦è¾¹å¾—åˆ°0ä¸ªï¼Œå³è¾¹å¾—åˆ°nä¸ªå…ƒç´ çš„æƒ…å†µï¼Œè¿™æ ·å³è¾¹ç»§ç»­é€’å½’ä¸‹å»æœ‰å¯èƒ½å§‹ç»ˆéƒ½æ˜¯nï¼ˆæ¯æ¬¡å–å‡ºpivotéƒ½æ˜¯æœ€å°å€¼ï¼‰ï¼Œé‚£ä¹ˆä¼šå‡ºç°æ— é™é€’å½’ã€‚
  - ä¸ºä»€ä¹ˆåœ¨whileå†…éƒ¨è¿˜è¦æ£€æµ‹`left <= right`?
  é˜²æ­¢`A[left] < pivot` æˆ–è€… `A[right] > pivot` è¶Šç•Œ
  ```java
  private void quickSort(int[] A, int start, int end) {
          if (start >= end) {
              return;
          }
          
          int left = start, right = end;
          // key point 1: pivot is the value, not the index
          int pivot = A[(start + end) / 2];
  
          // key point 2: every time you compare left & right, it should be 
          // left <= right not left < right (å¦‚æœæ²¡æœ‰=åˆ™æ¯æ¬¡éƒ½æ¼æ‰äº†æœ€åä¸€ä¸ªæ•°)
          while (left <= right) {
              // key point 3: A[left] < pivot not A[left] <= pivot
              while (left <= right && A[left] < pivot) {
                  left++;
              }
              // key point 3: A[right] > pivot not A[right] >= pivot
              while (left <= right && A[right] > pivot) {
                  right--;
              }
              if (left <= right) {
                  int temp = A[left];
                  A[left] = A[right];
                  A[right] = temp;
                  
                  left++;
                  right--;
              }
          }
          //æœ€åä¸€æ¬¡å¾ªç¯åleftå·²ç»åœ¨rightçš„å³è¾¹äº†
          quickSort(A, start, right);
          quickSort(A, left, end);
      }
  ```
  å½©è™¹æ’åºğŸŒˆ
  Non-randomly Picking the `Pivot`
  è¿™é‡Œ `while (l <= r && colors[l] <= colorMid)`
  å¯¹äºè¿™ä¸ªwhileå¾ªç¯ä¸ºä»€ä¹ˆæ˜¯<= ä¸æ˜¯ < , å®ƒä¸ºä»€ä¹ˆå’Œå¿«æ’ä¸ä¸€æ ·å‘¢ ï¼Ÿ
  é¦–å…ˆç”±å¦‚ä¸‹å‡ ä¸ªåœ°æ–¹å¤§å®¶éœ€è¦æ³¨æ„ï¼š
  å› ä¸ºrainbowSortçš„é€’å½’é‡Œ (..., colorMid + 1, colorTo)ï¼Œæ‰€ä»¥colorMidçš„å€¼ä¸èƒ½æ··åˆ°å³è¾¹å»ï¼Œå› ä¸ºå³è¾¹å€¼çš„åŒºé—´æ˜¯`[colorMid + 1, colorTo]`, å·¦è¾¹çš„å€¼æ˜¯`[colorFrom, colorMid]`ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠç­‰äºcolorMidçš„å€¼æ”¾åœ¨partitionçš„å·¦ä¾§ã€‚è€Œä¸æ˜¯åƒå¿«æ’ä¸€æ ·ï¼Œç­‰äºpivotçš„å€¼çš„å…ƒç´ æ”¾åœ¨å·¦ä¾§æˆ–è€…å³ä¾§æ˜¯æ— æ‰€è°“çš„ã€‚æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬åº”è¯¥åˆ†åˆ«ä½¿ç”¨`colors[l] <= colorMid` å’Œ `color[r] > colorMid`
  å› ä¸º`colorFrom >= colorTo`çš„æ—¶å€™æˆ‘ä»¬å·²ç»returnäº†ï¼Œæ‰€ä»¥æ±‚colorMidçš„æ—¶å€™ï¼ŒcolorFromä¸€å®šä¸ç­‰äºcolorToã€‚åˆå› ä¸º`colorMid = ï¼ˆcolorFrom + colorToï¼‰ / 2`, æ‰€ä»¥colorMidä¸€å®šä¸ä¼šç­‰äºæœ€å¤§å€¼colorToï¼Œä¹Ÿå°±é¿å…äº†æˆ‘ä»¬æ‰€è¯´çš„å› ä¸ºpivotæ˜¯æœ€å¤§å€¼è€Œå¯¼è‡´æ— é™é€’å½’çš„é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ”¾å¿ƒçš„ä½¿ç”¨<=ã€‚
  ```java
  private void rainbowSort(int[] colors,
                        int start,
                        int end,
                        int colorFrom, 
                        int colorTo){
          if(start >= end){
              return;
          }           
          if(colorFrom >= colorTo){
              return;
          }
          int left = start;
          int right = end;
          int colorMid = (colorFrom + colorTo) / 2;
          while(left <= right){
              //æ³¨æ„è¿™é‡Œæ˜¯colors[left] <= colorMid,å› ä¸ºåœ¨é€’å½’æ—¶colorMidåªèƒ½å»å·¦è¾¹
              while(left <= right && colors[left] <= colorMid){
                  left++;
              }
              while(left <= right && colors[right] > colorMid){
                  right--;
              }
              if(left <= right){
                  int temp = colors[left];
                  colors[left] = colors[right];
                  colors[right] = temp;
                  left++;
                  right--;
              }
          }
          rainbowSort(colors, start, right, colorFrom, colorMid);
          rainbowSort(colors, left, end, colorMid + 1, colorTo);
      }
  ```
  ### Heap Sort
  | Best TC | Average TC | Worst TC | Space C |
  | ------- | ---------  | -------- | ------- |
  | `O(nlogn)`	| `O(nlogn)` | 	`O(nlogn)` | `O(1)` |
  ![](https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif)
  ```java
  public void sort(int arr[])
      {
          int n = arr.length;
   
          // Build heap (rearrange array)
          for (int i = n / 2 - 1; i >= 0; i--)
              heapify(arr, n, i);
   
          // One by one extract an element from heap
          for (int i=n-1; i>=0; i--)
          {
              // Move current root to end
              int temp = arr[0];
              arr[0] = arr[i];
              arr[i] = temp;
   
              // call max heapify on the reduced heap
              heapify(arr, i, 0);
          }
      }
   
      // To heapify a subtree rooted with node i which is
      // an index in arr[]. n is size of heap
      void heapify(int arr[], int n, int i)
      {
          int largest = i;  // Initialize largest as root
          int l = 2*i + 1;  // left = 2*i + 1
          int r = 2*i + 2;  // right = 2*i + 2
   
          // If left child is larger than root
          if (l < n && arr[l] > arr[largest])
              largest = l;
   
          // If right child is larger than largest so far
          if (r < n && arr[r] > arr[largest])
              largest = r;
   
          // If largest is not root
          if (largest != i)
          {
              int swap = arr[i];
              arr[i] = arr[largest];
              arr[largest] = swap;
   
              // Recursively heapify the affected sub-tree
              heapify(arr, n, largest);
          }
      }
  ```
'''
tags: []
isStarred: false
isTrashed: false
createdAt: "2017-08-21T13:19:26.494Z"
updatedAt: "2017-09-09T00:38:29.640Z"
