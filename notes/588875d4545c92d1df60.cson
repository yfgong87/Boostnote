type: "MARKDOWN_NOTE"
folder: "0ef4dc321cdc22cb8b00"
title: "Quick Sort, Heap Sort"
content: '''
  # Quick Sort, Heap Sort
  ### Quick Sort
  | Best TC | Average TC | Worst TC | Space C |
  | ------- | ---------  | -------- | ------- |
  | `O(nlogn)`	| `O(nlogn)` | 	`O(n^2)` | `O(logn)` |
  - `logn` space complexity because of stack use in recursion
  ![](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)
  
  ### å¿«æ’ä¹ç« æ¨¡æ¿
  - ä¸ºä»€ä¹ˆè¦ç”¨`left<=right`? (`æ³¨æ„`: æ‰€æœ‰partitionç±»é—®é¢˜éƒ½é€‚ç”¨)
  å› ä¸ºæˆ‘ä»¬ä¸å¸Œæœ›ç­‰äºçš„æ—¶å€™åœä¸‹æ¥ï¼Œè€Œæ˜¯partitionæˆä¸¤ä»½ï¼Œæ­£åœ¨æ„ä¹‰ä¸Šåˆ†å¼€ï¼Œæ‰€ä»¥ç”¨äº†`left <= right` ä½¿å¾—ç»“æŸçš„æ—¶å€™`right`ä¸€å®šå°äº`left`
  - ä¸ºä»€ä¹ˆè¿™é‡Œæ˜¯`A[left] < pivot` è€Œä¸æ˜¯ `A[left] <= pivot` ?
  å› ä¸ºå¦‚æœpivotåˆšå¥½æ˜¯æœ€å¤§å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯¹nä¸ªå…ƒç´ è¿›è¡Œpartitionå°±ä¼šå‡ºç°å·¦è¾¹å¾—åˆ°nä¸ªï¼Œå³è¾¹å¾—åˆ°0ä¸ªå…ƒç´ çš„æƒ…å†µï¼Œè¿™æ ·å·¦è¾¹ç»§ç»­é€’å½’ä¸‹å»æœ‰å¯èƒ½å§‹ç»ˆéƒ½æ˜¯nï¼ˆæ¯æ¬¡å–å‡ºpivotéƒ½æ˜¯æœ€å¤§å€¼ï¼‰ï¼Œé‚£ä¹ˆä¼šå‡ºç°æ— é™é€’å½’ã€‚
  - ä¸ºä»€ä¹ˆè¿™é‡Œæ˜¯`A[right] > pivot` è€Œä¸æ˜¯ `A[right] >= pivot` ?
  åŒç†ï¼Œå› ä¸ºå¦‚æœpivotåˆšå¥½æ˜¯æœ€å°å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯¹nä¸ªå…ƒç´ è¿›è¡Œpartitionå°±ä¼šå‡ºç°å·¦è¾¹å¾—åˆ°0ä¸ªï¼Œå³è¾¹å¾—åˆ°nä¸ªå…ƒç´ çš„æƒ…å†µï¼Œè¿™æ ·å³è¾¹ç»§ç»­é€’å½’ä¸‹å»æœ‰å¯èƒ½å§‹ç»ˆéƒ½æ˜¯nï¼ˆæ¯æ¬¡å–å‡ºpivotéƒ½æ˜¯æœ€å°å€¼ï¼‰ï¼Œé‚£ä¹ˆä¼šå‡ºç°æ— é™é€’å½’ã€‚
  - ä¸ºä»€ä¹ˆåœ¨whileå†…éƒ¨è¿˜è¦æ£€æµ‹`left <= right`?
  é˜²æ­¢`A[left] < pivot` æˆ–è€… `A[right] > pivot` è¶Šç•Œ
  ```java
  private void quickSort(int[] A, int start, int end) {
          if (start >= end) {
              return;
          }
          
          int left = start, right = end;
          // key point 1: pivot is the value, not the index
          int pivot = A[(start + end) / 2];
  
          // key point 2: every time you compare left & right, it should be 
          // left <= right not left < right (å¦‚æœæ²¡æœ‰=åˆ™æ¯æ¬¡éƒ½æ¼æ‰äº†æœ€åä¸€ä¸ªæ•°)
          while (left <= right) {
              // key point 3: A[left] < pivot not A[left] <= pivot
              while (left <= right && A[left] < pivot) {
                  left++;
              }
              // key point 3: A[right] > pivot not A[right] >= pivot
              while (left <= right && A[right] > pivot) {
                  right--;
              }
              if (left <= right) {
                  int temp = A[left];
                  A[left] = A[right];
                  A[right] = temp;
                  
                  left++;
                  right--;
              }
          }
          //æœ€åä¸€æ¬¡å¾ªç¯åleftå·²ç»åœ¨rightçš„å³è¾¹äº†
          quickSort(A, start, right);
          quickSort(A, left, end);
      }
  ```
  å½©è™¹æ’åºğŸŒˆ
  Non-randomly Picking the `Pivot`
  è¿™é‡Œ `while (l <= r && colors[l] <= colorMid)`
  å¯¹äºè¿™ä¸ªwhileå¾ªç¯ä¸ºä»€ä¹ˆæ˜¯<= ä¸æ˜¯ < , å®ƒä¸ºä»€ä¹ˆå’Œå¿«æ’ä¸ä¸€æ ·å‘¢ ï¼Ÿ
  é¦–å…ˆç”±å¦‚ä¸‹å‡ ä¸ªåœ°æ–¹å¤§å®¶éœ€è¦æ³¨æ„ï¼š
  å› ä¸ºrainbowSortçš„é€’å½’é‡Œ (..., colorMid + 1, colorTo)ï¼Œæ‰€ä»¥colorMidçš„å€¼ä¸èƒ½æ··åˆ°å³è¾¹å»ï¼Œå› ä¸ºå³è¾¹å€¼çš„åŒºé—´æ˜¯`[colorMid + 1, colorTo]`, å·¦è¾¹çš„å€¼æ˜¯`[colorFrom, colorMid]`ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠç­‰äºcolorMidçš„å€¼æ”¾åœ¨partitionçš„å·¦ä¾§ã€‚è€Œä¸æ˜¯åƒå¿«æ’ä¸€æ ·ï¼Œç­‰äºpivotçš„å€¼çš„å…ƒç´ æ”¾åœ¨å·¦ä¾§æˆ–è€…å³ä¾§æ˜¯æ— æ‰€è°“çš„ã€‚æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬åº”è¯¥åˆ†åˆ«ä½¿ç”¨`colors[l] <= colorMid` å’Œ `color[r] > colorMid`
  å› ä¸º`colorFrom >= colorTo`çš„æ—¶å€™æˆ‘ä»¬å·²ç»returnäº†ï¼Œæ‰€ä»¥æ±‚colorMidçš„æ—¶å€™ï¼ŒcolorFromä¸€å®šä¸ç­‰äºcolorToã€‚åˆå› ä¸º`colorMid = ï¼ˆcolorFrom + colorToï¼‰ / 2`, æ‰€ä»¥colorMidä¸€å®šä¸ä¼šç­‰äºæœ€å¤§å€¼colorToï¼Œä¹Ÿå°±é¿å…äº†æˆ‘ä»¬æ‰€è¯´çš„å› ä¸ºpivotæ˜¯æœ€å¤§å€¼è€Œå¯¼è‡´æ— é™é€’å½’çš„é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ”¾å¿ƒçš„ä½¿ç”¨<=ã€‚
  ```java
  private void rainbowSort(int[] colors,
                        int start,
                        int end,
                        int colorFrom, 
                        int colorTo){
          if(start >= end){
              return;
          }           
          if(colorFrom >= colorTo){
              return;
          }
          int left = start;
          int right = end;
          int colorMid = (colorFrom + colorTo) / 2;
          while(left <= right){
              //æ³¨æ„è¿™é‡Œæ˜¯colors[left] <= colorMid,å› ä¸ºåœ¨é€’å½’æ—¶colorMidåªèƒ½å»å·¦è¾¹
              while(left <= right && colors[left] <= colorMid){
                  left++;
              }
              while(left <= right && colors[right] > colorMid){
                  right--;
              }
              if(left <= right){
                  int temp = colors[left];
                  colors[left] = colors[right];
                  colors[right] = temp;
                  left++;
                  right--;
              }
          }
          rainbowSort(colors, start, right, colorFrom, colorMid);
          rainbowSort(colors, left, end, colorMid + 1, colorTo);
      }
  ```
  ğŸŒˆå½©è™¹æ’åºçš„`HashMap`åšæ³•(`O(k)` extra memory)
  ```java
  class Solution {
      /**
       * @param colors: A list of integer
       * @param k: An integer
       * @return: nothing
       */
      public void sortColors2(int[] colors, int k) {
          // write your code here
          if(colors == null || colors.length == 0){
              return;
          }
          Map<Integer, Integer> map = new HashMap<Integer, Integer>();
          for(int color : colors){
              if(!map.containsKey(color)){
                  map.put(color, 1);
              } else {
                  map.put(color, map.get(color) + 1);
              }
          }
          int index = 0;
          for(int color = 1; color <= k; color++){
              if(!map.containsKey(color)){
                  continue;
              }
              for(int i = 0; i < map.get(color); i++){
                  colors[index] = color;
                  index++;
              }
          }
      }
  
  }
  ```
  
  ### Heap Sort
  | Best TC | Average TC | Worst TC | Space C |
  | ------- | ---------  | -------- | ------- |
  | `O(nlogn)`	| `O(nlogn)` | 	`O(nlogn)` | `O(1)` |
  ![](https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif)
  ```java      
  public void sort(int arr[])
      {
          int n = arr.length;
   
          // Build heap (rearrange array)
          for (int i = n / 2 - 1; i >= 0; i--)
              heapify(arr, n, i);
   
          // One by one extract an element from heap
          for (int i=n-1; i>=0; i--)
          {
              // Move current root (arr[0]) to end
              int temp = arr[0];
              arr[0] = arr[i];
              arr[i] = temp;
   
              // call max heapify on the reduced heap
              heapify(arr, i, 0);
          }
      }
      /*
      Does this satisfy the head-order property?
  
                      20
              5              10
          12    15        8      2
        6   2  9
  
  
      Note that this can also be written an array format as:
          20 5 10 12 15 8 2 6 2 9
  
      No, but   12      15    are heaps.
               6  2    9
      */
      // To heapify a subtree rooted with node i which is
      // an index in arr[]. n is size of heap
      void heapify(int arr[], int n, int i)
      {
          int largest = i;  // Initialize largest as root
          int l = 2*i + 1;  // left = 2*i + 1
          int r = 2*i + 2;  // right = 2*i + 2
   
          // If left child is larger than root
          if (l < n && arr[l] > arr[largest])
              largest = l;
   
          // If right child is larger than largest so far
          if (r < n && arr[r] > arr[largest])
              largest = r;
   
          // If largest is not root
          if (largest != i)
          {
              int swap = arr[i];
              arr[i] = arr[largest];
              arr[largest] = swap;
   
              // Recursively heapify the affected sub-tree
              heapify(arr, n, largest);
          }
      }
  ```
  `Non-recursive` version
  ```java
  void siftdown(int arr[], int n, int i)
      {
          //i æ˜¯å½“å‰å­æ ‘çš„æ ¹
          while(i < n){
            int largest = i;  // Initialize largest as root
            int l = 2*i + 1;  // left = 2*i + 1
            int r = 2*i + 2;  // right = 2*i + 2
   
            // If left child is larger than root
            if (l < n && arr[l] > arr[largest])
                largest = l;
   
            // If right child is larger than largest so far
            if (r < n && arr[r] > arr[largest])
                largest = r;
   
            // If largest is root, break
            if (largest == i) break;
            // If largest is not root, swap
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;
            // ç»§ç»­æ£€éªŒæ¢è¿‡å»çš„rootæ˜¯ä¸æ˜¯è¯¥subtreeé‡Œçš„æœ€å¤§
            i = largest;
          }
      }
      
  public void heapify(int[] A) {
        int n = A.length;
        //è¿™é‡Œæ²¡æœ‰ -1 ä¹Ÿèƒ½è¿‡ï¼Œä½†æ˜¯ n / 2 æ˜¯æ²¡æœ‰å¶å­èŠ‚ç‚¹çš„ï¼Œæ‰€ä»¥æ²¡æœ‰å¿…è¦è¿›å…¥å¾ªç¯ï¼Œn / 2 - 1 æ›´å¥½
        for (int i = n / 2 - 1; i >= 0; i--) {
            siftdown(A, n, i);
        } 
    }
  ```
'''
tags: []
isStarred: false
isTrashed: false
createdAt: "2017-08-21T13:19:26.494Z"
updatedAt: "2017-10-07T16:28:24.794Z"
