type: "MARKDOWN_NOTE"
folder: "8d19d56ee029f3fa592b"
title: "Balanced Binary Tree"
content: '''
  # Balanced Binary Tree 
  Check if a given binary tree is balanced. A balanced binary tree is one in which the depths of every node’s left and right subtree differ by at most 1.
  
  My general solution is to recursively traverse every node in the tree, and check for every node, whether the absolute difference of depth between its left and right child is not greater than 1. The helper function will recursively be ran on every node and return two values: 1) the max depth of a node and 2) whether the tree that root from this node is balanced or not.
  
  ```java
  class returnType{
      int depth;
      boolean isBalanced;
      returnType(int depth, boolean isBalanced){
          this.depth = depth;
          this.isBalanced = isBalanced;
      }
  }
  public class Solution {
      /*
       * @param root: The root of binary tree.
       * @return: True if this Binary tree is Balanced, or false.
       */
      public boolean isBalanced(TreeNode root) {
          // write your code here
          return helper(root).isBalanced;
      }
      private returnType helper(TreeNode root){
          if(root == null){
              return new returnType(0, true);
          }
  /*								
          if(root.left == null && root.right == null){
              return new returnType(1, true);
          }
  */
          returnType left = helper(root.left);
          returnType right = helper(root.right);
          boolean isBalanced = true;
          //如果tree的subtree中之一不是balanced或者两者depth相差大于一，tree不balance
          if(!left.isBalanced || !right.isBalanced || Math.abs(left.depth - right.depth) > 1){
              isBalanced = false;
          }
          //注意这里是Math.max而不是left + right + 1！
          return new returnType(Math.max(left.depth, right.depth) + 1, isBalanced);
      }
  }
  ```
'''
tags: []
isStarred: false
isTrashed: false
createdAt: "2017-09-01T02:09:07.152Z"
updatedAt: "2017-12-13T04:42:55.153Z"
