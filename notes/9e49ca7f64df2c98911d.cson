type: "MARKDOWN_NOTE"
folder: "8d19d56ee029f3fa592b"
title: "Remove Duplicate 系列"
content: '''
  # Remove Duplicate 系列
  ### Remove Duplicate in Array
  不要求保持原来顺序，只需要不重复的数在数组前面就行了
  ```java
  public class Solution {
      /**
       * @param nums an array of integers
       * @return the number of unique integers
       */
      public int deduplication(int[] nums) {
          // Write your code here
          if(nums == null || nums.length == 0){
              return 0;
          }
          Arrays.sort(nums);
          int left = 0;
          int right = 0;
          while(right < nums.length){
              if(nums[left] == nums[right]){
                  right++;  //右指针跳过重复数
              } else {
                  nums[++left] = nums[right++]; //左指针永远指向重复数前一位
              }
          }
          return left + 1;
      }
  }
  ```
  ### Remove Duplicate in Array II
  Duplicate are allowed at most twice
  ```java
  public int removeDuplicates(int[] nums) {
          // write your code here
          if(nums == null || nums.length == 0){
              return 0;
          }
          int left = 0;
          int right = 1; //right 从 1 开始
          int count = 1; //增加一个count，从 1 开始
          while(right < nums.length){
              if(nums[right] == nums[left]){
                  if(count < 2){ //当不足两次时
                      nums[++left] = nums[right++];
                      count++;
                  } else {  //只有当重复数出现大于两次时，右指针跳过重复数
                      right++;
                  }
              } else {
                  nums[++left] = nums[right++];
                  count = 1; //重置count
              }
          }
          return left + 1;
      }
  ```
  ### Remove Duplicate in List
  Given `1->2->3->3->4->4->5`, return `1->2->3->4->5`.
  ```java
  //完全模仿Array的做法
  public ListNode deleteDuplicates(ListNode head) {
          // write your code here
          if(head == null){
              return head;
          }
          ListNode left = head, right = head;
          while(right != null){
              if(left.val == right.val){
                  right = right.next;
              } else {
                  left = left.next;
                  left.val = right.val;
                  right = right.next;
              }
          }
          left.next = null;
          return head;
      }
      
  //直接删除重复点的做法
  public ListNode deleteDuplicates(ListNode head) {
          // write your code here
          if(head == null){
              return head;
          }
          ListNode curr = head;
          while(curr.next != null){
              if(curr.val == curr.next.val){
                  curr.next = curr.next.next;
              } else {
                  curr = curr.next;
              }
          }
          return head;
      }
  ```
  ### Remove Duplicate in List II
  Given `1->2->3->3->4->4->5`, return `1->2->5`.
  ```java
  public ListNode deleteDuplicates(ListNode head) {
          // write your code here
          if(head == null || head.next == null){
              return head;
          }
          ListNode dummy = new ListNode(0), curr = dummy;
          dummy.next = head;
          while(curr.next != null && curr.next.next != null){
              if(curr.next.val == curr.next.next.val){
                  int val = curr.next.val;
                  while(curr.next != null && curr.next.val == val){
                      curr.next = curr.next.next;
                  }
              } else {
                  curr = curr.next;
              }
          }
          return dummy.next;
      }
  ```
  ### Remove Element
  Given an array and a value, remove all occurrences of that value in place and return the new length.
  
  The order of elements can be changed, and the elements after the new length don't matter.
  ```java
  public int removeElement(int[] A, int elem) {
          // write your code here
          if(A == null || A.length == 0){
              return 0;
          }
          int left = 0;
          int right = A.length - 1;
          while(left < right){
              while(left < right && A[left] != elem){
                  left++;
              }
              while(left < right && A[right] == elem){
                  right--;
              }
              if(left < right){
                  int temp = A[left];
                  A[left] = A[right];
                  A[right] = temp;
                  left++;
                  right--;
              }
          }
          //最后 left 指向的数可能等于或不等于 elem
          if(A[left] == elem){
              return left;
          }
          return left + 1;
      }
      ```
'''
tags: []
isStarred: false
isTrashed: false
createdAt: "2017-10-06T18:18:09.235Z"
updatedAt: "2017-10-23T03:26:14.655Z"
