createdAt: "2017-08-21T13:19:26.494Z"
updatedAt: "2018-01-06T19:28:13.337Z"
type: "MARKDOWN_NOTE"
folder: "c7615b6dcc7b2832aa16"
title: "Quick Sort"
content: '''
  # Quick Sort
  ### Quick Sort
  | Best TC | Average TC | Worst TC | Space C |
  | ------- | ---------  | -------- | ------- |
  | `O(nlogn)`	| `O(nlogn)` | 	`O(n^2)` | `O(logn)` |
  - `logn` space complexity because of stack use in recursion
  ![](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)
  
  #### å¿«æ’å¤æ‚åº¦åˆ†æ
  å¿«æ’çš„æ—¶é—´å¤æ‚åº¦æ˜¯ï¼š`T(n)` = `2T(n/2)` + `O(n)`
  æç«¯æƒ…å†µï¼š`T[n]` = `T[n-1]` + `T[1]` + `O(n)`ï¼Œè¿™ä¸€æ¬¡çš„åˆ’åˆ†ç™½ç©äº†ï¼Œåˆ’åˆ†ä¹‹åä¸€è¾¹æ˜¯ä¸€ä¸ªï¼Œä¸€è¾¹æ˜¯n-1ä¸ªï¼Œè¿™ç§æç«¯æƒ…å†µçš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯`O(n^2)`.
  
  #### å¿«æ’ä¹ç« æ¨¡æ¿
  - ä¸ºä»€ä¹ˆè¦ç”¨`left<=right`? (`æ³¨æ„`: æ‰€æœ‰partitionç±»é—®é¢˜éƒ½é€‚ç”¨)
  å› ä¸ºæˆ‘ä»¬ä¸å¸Œæœ›ç­‰äºçš„æ—¶å€™åœä¸‹æ¥ï¼Œè€Œæ˜¯partitionæˆä¸¤ä»½ï¼Œæ­£åœ¨æ„ä¹‰ä¸Šåˆ†å¼€ï¼Œæ‰€ä»¥ç”¨äº†`left <= right` ä½¿å¾—ç»“æŸçš„æ—¶å€™`right`ä¸€å®šå°äº`left`
  - ä¸ºä»€ä¹ˆè¿™é‡Œæ˜¯`A[left] < pivot` è€Œä¸æ˜¯ `A[left] <= pivot` ?
  å› ä¸ºå¦‚æœpivotåˆšå¥½æ˜¯æœ€å¤§å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯¹nä¸ªå…ƒç´ è¿›è¡Œpartitionå°±ä¼šå‡ºç°å·¦è¾¹å¾—åˆ°nä¸ªï¼Œå³è¾¹å¾—åˆ°0ä¸ªå…ƒç´ çš„æƒ…å†µï¼Œè¿™æ ·å·¦è¾¹ç»§ç»­é€’å½’ä¸‹å»æœ‰å¯èƒ½å§‹ç»ˆéƒ½æ˜¯nï¼ˆæ¯æ¬¡å–å‡ºpivotéƒ½æ˜¯æœ€å¤§å€¼ï¼‰ï¼Œé‚£ä¹ˆä¼šå‡ºç°æ— é™é€’å½’ã€‚
  - ä¸ºä»€ä¹ˆè¿™é‡Œæ˜¯`A[right] > pivot` è€Œä¸æ˜¯ `A[right] >= pivot` ?
  åŒç†ï¼Œå› ä¸ºå¦‚æœpivotåˆšå¥½æ˜¯æœ€å°å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯¹nä¸ªå…ƒç´ è¿›è¡Œpartitionå°±ä¼šå‡ºç°å·¦è¾¹å¾—åˆ°0ä¸ªï¼Œå³è¾¹å¾—åˆ°nä¸ªå…ƒç´ çš„æƒ…å†µï¼Œè¿™æ ·å³è¾¹ç»§ç»­é€’å½’ä¸‹å»æœ‰å¯èƒ½å§‹ç»ˆéƒ½æ˜¯nï¼ˆæ¯æ¬¡å–å‡ºpivotéƒ½æ˜¯æœ€å°å€¼ï¼‰ï¼Œé‚£ä¹ˆä¼šå‡ºç°æ— é™é€’å½’ã€‚
  - ä¸ºä»€ä¹ˆåœ¨whileå†…éƒ¨è¿˜è¦æ£€æµ‹`left <= right`?
  é˜²æ­¢`A[left] < pivot` æˆ–è€… `A[right] > pivot` è¶Šç•Œ
  - ä¸€é Partition è¿‡åï¼Œ`pivot`å¯èƒ½åœ¨å·¦ä¾§ï¼Œä¹Ÿå¯èƒ½åœ¨å³ä¾§
  ```java
  private void quickSort(int[] A, int start, int end) {
          if (start >= end) {
              return;
          }
          
          int left = start, right = end;
          // key point 1: pivot is the value, not the index
          int pivot = A[(start + end) / 2];
  
          // key point 2: every time you compare left & right, it should be left <= right not left < right 
          while (left <= right) {
  			//A[left] < pivotï¼Œä¸èƒ½ <=ï¼Œå› ä¸ºå¦‚æœpivotåˆšå¥½æ˜¯æœ€å¤§å€¼
  			//left åœ¨å‘å³å‰è¿›æ—¶ä¼šè·³è¿‡pivotç›´æ¥åˆ°è¾¾arrayçš„æœ«ç«¯
  			//å¯¼è‡´partitionäº§ç”Ÿäº†ä¸€ä¸ªå’ŒåŸæ¥åŒæ ·çš„æ•°ç»„å’Œä¸€ä¸ªç©ºæ•°ç»„
  			//æ­¤æ—¶å¦‚æœç»§ç»­quickSortå°±ä¼šå¯¼è‡´å·¦è¾¹æ— é™å¾ªç¯å› ä¸ºæ¯ä¸€æ¬¡çš„pivotéƒ½æ­£å¥½æ˜¯æœ€å¤§å€¼)
              // key point 3: A[left] < pivot not A[left] <= pivot
              while (left <= right && A[left] < pivot) {
                  left++;
              }
              // key point 3: A[right] > pivot not A[right] >= pivot
              while (left <= right && A[right] > pivot) {
                  right--;
              }
              if (left <= right) {
                  int temp = A[left];
                  A[left] = A[right];
                  A[right] = temp;
                  
                  left++;
                  right--;
              }
          }
          //æœ€åä¸€æ¬¡å¾ªç¯åleftå·²ç»åœ¨rightçš„å³è¾¹äº†
          quickSort(A, start, right);
          quickSort(A, left, end);
      }
  ```
  ### List çš„ QuickSort
  ```java
  /**
   * Definition for ListNode.
   * public class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode(int val) {
   *         this.val = val;
   *         this.next = null;
   *     }
   * }
   */
  
  
  public class Solution {
      /*
       * @param head: The head of linked list.
       * @return: You should return the head of the sorted linked list, using constant space complexity.
       */
      public ListNode sortList(ListNode head) {
          // write your code here
          if(head == null || head.next == null){
              return head;
          }
          
          ListNode dummyLeft = new ListNode(0), currLeft = dummyLeft;
          ListNode dummyMid = new ListNode(0), currMid = dummyMid;
          ListNode dummyRight = new ListNode(0), currRight = dummyRight;
          
          ListNode mid = getMid(head);
          
          while(head != null){
              if(head.val < mid.val){
                  currLeft.next = head;
                  currLeft = currLeft.next;
              } else if(head.val > mid.val){
                  currRight.next = head;
                  currRight = currRight.next;
              } else {
                  currMid.next = head;
                  currMid = currMid.next;
              }
              head = head.next;
          }
          
  		// å½»åº• Partition ä¸‰éƒ¨åˆ†
          currLeft.next = null;
          currMid.next = null;
          currRight.next = null;
          
          ListNode left = sortList(dummyLeft.next);
          ListNode right = sortList(dummyRight.next);
          
          return concat(left, dummyMid.next, right);
      }
      
      public ListNode getMid(ListNode head){
          ListNode slow = head;
          ListNode fast = head.next;
          while(fast != null && fast.next != null){
              slow = slow.next;
              fast = fast.next.next;
          }
          return slow;
      }
      
      public ListNode concat(ListNode left, ListNode mid, ListNode right){
          ListNode dummy = new ListNode(0), tail = dummy;
  		//tail.next = left; tail = getTail(left);
          //tail.next = mid; tail = getTail(mid);
  		//ä¸Šé¢çš„å†™æ³•é”™è¯¯ï¼Œå› ä¸ºleftæœ‰å¯èƒ½ä¸ºnullï¼Œå¦‚æœleft==nullï¼Œé‚£ä¹ˆtail=getTail(left)åtailä¹Ÿå°±ç­‰äºäº†nullï¼Œå†ä¹‹åçš„tail.next = middleï¼Œå°±ä¼šå‡ºç°NULL POINT EXCEPTION
          tail.next = left; tail = getTail(tail);
          tail.next = mid; tail = getTail(tail);
          tail.next = right;
          return dummy.next;
      }
      
      public ListNode getTail(ListNode head){
          if(head == null){
              return head;
          }
          while(head.next != null){
              head = head.next;
          }
          return head;
      }
  }
  ```
  ### å½©è™¹æ’åºğŸŒˆ
  å¾…ç¡®è®¤ï¼šæ—¶é—´å¤æ‚åº¦ä¸º `O(nlogk)`, `k`ä¸º `color`çš„æ•°ç›®
  
  Non-randomly Picking the `Pivot`
  è¿™é‡Œ `while (l <= r && colors[l] <= colorMid)`
  å¯¹äºè¿™ä¸ªwhileå¾ªç¯ä¸ºä»€ä¹ˆæ˜¯<= ä¸æ˜¯ < , å®ƒä¸ºä»€ä¹ˆå’Œå¿«æ’ä¸ä¸€æ ·å‘¢ ï¼Ÿ
  é¦–å…ˆç”±å¦‚ä¸‹å‡ ä¸ªåœ°æ–¹å¤§å®¶éœ€è¦æ³¨æ„ï¼š
  å› ä¸ºrainbowSortçš„é€’å½’é‡Œ (..., colorMid + 1, colorTo)ï¼Œæ‰€ä»¥colorMidçš„å€¼ä¸èƒ½æ··åˆ°å³è¾¹å»ï¼Œå› ä¸ºå³è¾¹å€¼çš„åŒºé—´æ˜¯`[colorMid + 1, colorTo]`, å·¦è¾¹çš„å€¼æ˜¯`[colorFrom, colorMid]`ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠç­‰äºcolorMidçš„å€¼æ”¾åœ¨partitionçš„å·¦ä¾§ã€‚è€Œä¸æ˜¯åƒå¿«æ’ä¸€æ ·ï¼Œç­‰äºpivotçš„å€¼çš„å…ƒç´ æ”¾åœ¨å·¦ä¾§æˆ–è€…å³ä¾§æ˜¯æ— æ‰€è°“çš„ã€‚æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬åº”è¯¥åˆ†åˆ«ä½¿ç”¨`colors[l] <= colorMid` å’Œ `color[r] > colorMid`
  å› ä¸º`colorFrom >= colorTo`çš„æ—¶å€™æˆ‘ä»¬å·²ç»returnäº†ï¼Œæ‰€ä»¥æ±‚colorMidçš„æ—¶å€™ï¼ŒcolorFromä¸€å®šä¸ç­‰äºcolorToã€‚åˆå› ä¸º`colorMid = ï¼ˆcolorFrom + colorToï¼‰ / 2`, æ‰€ä»¥colorMidä¸€å®šä¸ä¼šç­‰äºæœ€å¤§å€¼colorToï¼Œä¹Ÿå°±é¿å…äº†æˆ‘ä»¬æ‰€è¯´çš„å› ä¸ºpivotæ˜¯æœ€å¤§å€¼è€Œå¯¼è‡´æ— é™é€’å½’çš„é—®é¢˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ”¾å¿ƒçš„ä½¿ç”¨<=ã€‚
  ```java
  private void rainbowSort(int[] colors,
                        int start,
                        int end,
                        int colorFrom, 
                        int colorTo){
          if(start >= end){
              return;
          }           
          if(colorFrom >= colorTo){
              return;
          }
          int left = start;
          int right = end;
          int colorMid = (colorFrom + colorTo) / 2;
          while(left <= right){
              //æ³¨æ„è¿™é‡Œæ˜¯colors[left] <= colorMid,å› ä¸ºåœ¨é€’å½’æ—¶colorMidåªèƒ½å»å·¦è¾¹
              while(left <= right && colors[left] <= colorMid){
                  left++;
              }
              while(left <= right && colors[right] > colorMid){
                  right--;
              }
              if(left <= right){
                  int temp = colors[left];
                  colors[left] = colors[right];
                  colors[right] = temp;
                  left++;
                  right--;
              }
          }
          rainbowSort(colors, start, right, colorFrom, colorMid);
          rainbowSort(colors, left, end, colorMid + 1, colorTo);
      }
  ```
  ### Counting Sort
  ğŸŒˆå½©è™¹æ’åºçš„`HashMap`åšæ³•(`O(k)` extra memory)ï¼Œ `O(n)`æ—¶é—´å¤æ‚åº¦ 
  ```java
  class Solution {
      /**
       * @param colors: A list of integer
       * @param k: An integer
       * @return: nothing
       */
      public void sortColors2(int[] colors, int k) {
          // write your code here
          if(colors == null || colors.length == 0){
              return;
          }
          Map<Integer, Integer> map = new HashMap<Integer, Integer>();
          for(int color : colors){
              if(!map.containsKey(color)){
                  map.put(color, 1);
              } else {
                  map.put(color, map.get(color) + 1);
              }
          }
          int index = 0;
          for(int color = 1; color <= k; color++){
              if(!map.containsKey(color)){
                  continue;
              }
              for(int i = 0; i < map.get(color); i++){
                  colors[index] = color;
                  index++;
              }
          }
      }
  
  }
  ```
  
  ### Heap Sort
  å·¥ä¸šç•Œä¸ç”¨ Heap Sort çš„åŸå› æ˜¯å› ä¸ºæ¯æ¬¡æ‰¾åˆ°æœ€å¤§ï¼ˆå°ï¼‰å€¼åè¦å’Œæ•°ç»„çš„å¤´ï¼ˆå°¾ï¼‰äº’æ¢ï¼Œä¸¤ä¸ªåœ°å€å¯èƒ½éš”å¾—å¾ˆè¿œ
  
  | Best TC | Average TC | Worst TC | Space C |
  | ------- | ---------  | -------- | ------- |
  | `O(nlogn)`	| `O(nlogn)` | 	`O(nlogn)` | `O(1)` |
  ![](https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif)
  ```java      
  public void sort(int arr[])
      {
          int n = arr.length;
   
          // Build heap (rearrange array)
          for (int i = n / 2 - 1; i >= 0; i--)
              heapify(arr, n, i);
   
          // One by one extract an element from heap
          for (int i=n-1; i>=0; i--)
          {
              // Move current root (arr[0]) to end
              int temp = arr[0];
              arr[0] = arr[i];
              arr[i] = temp;
   
              // call max heapify on the reduced heap
              heapify(arr, i, 0);
          }
      }
      /*
      Does this satisfy the head-order property?
  
                      20
              5              10
          12    15        8      2
        6   2  9
  
  
      Note that this can also be written an array format as:
          20 5 10 12 15 8 2 6 2 9
  
      No, but   12      15    are heaps.
               6  2    9
      */
      // To heapify a subtree rooted with node i which is
      // an index in arr[]. n is size of heap
      void heapify(int arr[], int n, int i)
      {
          int largest = i;  // Initialize largest as root
          int l = 2*i + 1;  // left = 2*i + 1
          int r = 2*i + 2;  // right = 2*i + 2
   
          // If left child is larger than root
          if (l < n && arr[l] > arr[largest])
              largest = l;
   
          // If right child is larger than largest so far
          if (r < n && arr[r] > arr[largest])
              largest = r;
   
          // If largest is not root
          if (largest != i)
          {
              int swap = arr[i];
              arr[i] = arr[largest];
              arr[largest] = swap;
   
              // Recursively heapify the affected sub-tree
              heapify(arr, n, largest);
          }
      }
  ```
  `Non-recursive` version
  Actually, building a heap with repeated calls of `siftDown` has a complexity of `O(n)` whereas building it with repeated calls of `siftUp` has a complexity of `O(nlogn)`.
  
  This is due to the fact that when you use `siftDown`, the time taken by each call `decreases` with the depth of the node because these nodes are closer to the leaves. When you use `siftUp`, the number of swaps `increases` with the depth of the node because if you are at full depth, you may have to swap all the way to the root. As the number of nodes grows exponentially with the depth of the tree, using siftUp gives a more expensive algorithm.
  ```java
  void siftdown(int arr[], int n, int i)
      {
          //i æ˜¯å½“å‰å­æ ‘çš„æ ¹
          while(i < n){
            int largest = i;  // Initialize largest as root
            int l = 2*i + 1;  // left = 2*i + 1
            int r = 2*i + 2;  // right = 2*i + 2
   
            // If left child is larger than root
            if (l < n && arr[l] > arr[largest])
                largest = l;
   
            // If right child is larger than largest so far
            if (r < n && arr[r] > arr[largest])
                largest = r;
   
            // If largest is root, break
            if (largest == i) break;
            // If largest is not root, swap
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;
            // ç»§ç»­æ£€éªŒæ¢è¿‡å»çš„rootæ˜¯ä¸æ˜¯è¯¥subtreeé‡Œçš„æœ€å¤§
            i = largest;
          }
      }
      
  public void heapify(int[] A) {
        int n = A.length;
        //è¿™é‡Œæ²¡æœ‰ -1 ä¹Ÿèƒ½è¿‡ï¼Œä½†æ˜¯ n / 2 æ˜¯æ²¡æœ‰å¶å­èŠ‚ç‚¹çš„ï¼Œæ‰€ä»¥æ²¡æœ‰å¿…è¦è¿›å…¥å¾ªç¯ï¼Œn / 2 - 1 æ›´å¥½
        for (int i = n / 2 - 1; i >= 0; i--) {
            siftdown(A, n, i);
        } 
    }
  ```
'''
tags: [
  "PocketGem"
]
isStarred: false
isTrashed: false
