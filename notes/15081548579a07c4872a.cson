type: "MARKDOWN_NOTE"
folder: "8d19d56ee029f3fa592b"
title: "Subarray Anagram"
content: '''
  # Subarray Anagram
  普通版
  首先先`小String`中的每个`Char`出现次数存在`HashMap`里
  然后枚举`大String`中长度等于`小String`的所有`SubString`，每个`SubString`中每个`Char`出现的次数也存在`HashMap`里
  然后比较两个`HashMap`是否相等。每次存`HashMap`理论需要`O(l)`其中`l`为`小String`的长度
  如果用一个大小为`256`的`Array`代替`HashMap`，并且用`Sliding Window`仅仅修改变动的那一个`Char`，则将`O(l)`简化为了`O(1)`
  `Arrays.equals()` 复杂度为 `O(n)`
  由于比较的是大小为`256`的两个`Array`，所以总复杂度为 `O(n * 256)`
  ```java
  public class Solution {
      /*
       * @param s: a string
       * @param p: a string
       * @return: a list of index
       */
  	// idx:  01234
  	//   s:  abcde
  	//  s':  abc
  	// s'':   bcd
  	//s\''':    cde
  	//   p:  acb
      public List<Integer> findAnagrams(String s, String p) {
          // write your code here
          List<Integer> result = new ArrayList<Integer>();
          if(s.length() < p.length()){
              return result;
          }
          int[] mapS = new int[256];
          int[] mapP = new int[256];
          char[] sc = s.toCharArray();
          char[] pc = p.toCharArray();
          for(int i = 0; i < p.length(); i++){
              mapS[sc[i]]++;
              mapP[pc[i]]++;
          }
          if(Arrays.equals(mapS, mapP)){
              result.add(0);
          }
          for(int i = 1; i <= s.length() - p.length(); i++){
              mapS[sc[i - 1]]--;
              mapS[sc[i + p.length() - 1]]++;
              if(Arrays.equals(mapS, mapP)){
                  result.add(i);
              }
          }
          return result;
      }
  }
  ```
  `absSum`优化版
  ```java
  public class Solution {
      /*
       * @param s: a string
       * @param p: a string
       * @return: a list of index
       */
      public List<Integer> findAnagrams(String s, String p) {
          // write your code here
          List<Integer> result = new ArrayList<Integer>();
          if(s.length() < p.length()){
              return result;
          }
          int[] difMap = new int[256];
          char[] sc = s.toCharArray();
          char[] pc = p.toCharArray();
          for(int i = 0; i < p.length(); i++){
              difMap[sc[i]]++;
              difMap[pc[i]]--;
          }
          int absSum = 0;
          for(int i : difMap){
              absSum += Math.abs(i);
          }
          if(absSum == 0){
              result.add(0);
          }
          for(int i = 1; i <= s.length() - p.length(); i++){
              int left = sc[i - 1];
              int right = sc[i + p.length() - 1];
              absSum = absSum - Math.abs(difMap[left]) - Math.abs(difMap[right]);
              difMap[left]--;
              difMap[right]++;
              absSum = absSum + Math.abs(difMap[left]) + Math.abs(difMap[right]);
              if(absSum == 0){
                  result.add(i);
              }
          }
          return result;
      }
  }
  ```
'''
tags: []
isStarred: false
isTrashed: true
createdAt: "2017-09-21T22:47:43.819Z"
updatedAt: "2017-12-27T01:33:03.882Z"
